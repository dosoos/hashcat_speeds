<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <title>Hashcat GPU Benchmark Data Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- DaisyUI & Tailwind -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@4.10.2/dist/full.css" rel="stylesheet" type="text/css" />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Chart.js datalabels plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
</head>
<body class="bg-base-200 min-h-screen">
  <div class="container mx-auto p-4">
    <h1 class="text-3xl font-bold text-center mb-8">Hashcat GPU Benchmark Data Visualization</h1>
    
    <!-- Loading indicator -->
    <div id="loading" class="text-center">
      <div class="loading loading-spinner loading-lg"></div>
      <p class="mt-4" id="loading-text">Loading benchmark data...</p>
    </div>
    
    <!-- Main content -->
    <div id="main-content" class="hidden">
      <!-- Hash mode selector -->
      <div class="card bg-base-100 shadow-xl mb-6">
        <div class="card-body">
          <h2 class="card-title">Select Hash Mode</h2>
          <div class="form-control w-full">
            <label class="label">
              <span class="label-text">Search and choose a hash mode to visualize:</span>
            </label>
            <div class="relative">
              <input 
                type="text" 
                id="hashModeSearch" 
                placeholder="Search hash modes..." 
                class="input input-bordered w-full pr-16"
                autocomplete="off"
              />
              <button 
                type="button" 
                id="clearSearch" 
                class="btn btn-ghost btn-sm absolute right-0 top-0 h-full px-2"
                style="display: none;"
              >
                âœ•
              </button>
            </div>
            <div id="hashModeDropdown" class="dropdown-content bg-base-100 rounded-box z-[1] w-full shadow-lg border border-base-300" style="display: none; max-height: 300px; overflow-y: auto;">
              <!-- Options will be populated here -->
            </div>
          </div>
        </div>
      </div>
      
      <!-- Chart container -->
      <div class="card bg-base-100 shadow-xl">
        <div class="card-body">
          <h2 class="card-title" id="chartTitle">GPU Performance Comparison</h2>
          <div class="w-full" id="chartContainer">
            <canvas id="performanceChart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Register Chart.js datalabels plugin
    Chart.register(ChartDataLabels);
    
    // Global variables
    let benchmarkData = {};
    let availableHashModes = [];
    let chart = null;
    let selectedHashMode = '';
    let filteredHashModes = [];
    
    // Function to format speed values
    function formatSpeed(speed) {
      if (speed >= 1e12) {
        return (speed / 1e12).toFixed(1) + ' TH/s';
      } else if (speed >= 1e9) {
        return (speed / 1e9).toFixed(1) + ' GH/s';
      } else if (speed >= 1e6) {
        return (speed / 1e6).toFixed(1) + ' MH/s';
      } else if (speed >= 1e3) {
        return (speed / 1e3).toFixed(1) + ' kH/s';
      } else {
        return speed.toFixed(1) + ' H/s';
      }
    }
    
    
    // Function to load all benchmark data from datas.json
    async function loadAllBenchmarkData() {
      const loadingElement = document.getElementById('loading');
      const mainContent = document.getElementById('main-content');
      
      try {
        console.log('Loading benchmark data from datas.json...');
        document.getElementById('loading-text').textContent = 'Loading benchmark data from datas.json...';
        
        const response = await fetch('datas.json');
        if (!response.ok) {
          throw new Error('Failed to load datas.json');
        }
        
        // Load the complete benchmark data directly
        benchmarkData = await response.json();
        
        // Collect all hash modes from all devices
        const allHashModes = new Set();
        Object.values(benchmarkData).forEach(deviceData => {
          Object.keys(deviceData).forEach(mode => allHashModes.add(mode));
        });
        
        // Sort hash modes by ID
        availableHashModes = Array.from(allHashModes).sort((a, b) => {
          const aId = parseInt(a.split(' ')[2]);
          const bId = parseInt(b.split(' ')[2]);
          return aId - bId;
        });
        
        console.log(`Found ${availableHashModes.length} unique hash modes:`, availableHashModes);
        console.log(`Loaded ${Object.keys(benchmarkData).length} devices:`, Object.keys(benchmarkData));
        
        // Initialize search functionality
        initializeHashModeSearch();
        
        // Auto-select and display the first hash mode
        if (availableHashModes.length > 0) {
          const firstHashMode = availableHashModes[0];
          const firstDeviceWithMode = Object.keys(benchmarkData).find(device => 
            benchmarkData[device][firstHashMode]
          );
          const modeName = firstDeviceWithMode ? 
            benchmarkData[firstDeviceWithMode][firstHashMode].hashmode_name : 'Unknown';
          
          // Set the selected hash mode
          selectedHashMode = firstHashMode;
          
          // Update search input to show selected mode
          document.getElementById('hashModeSearch').value = `${firstHashMode} (${modeName})`;
          document.getElementById('clearSearch').style.display = 'block';
          
          // Display the chart for the first hash mode
          updateChart(firstHashMode);
        }
        
        // Hide loading, show main content
        document.getElementById('loading-text').textContent = 
          `Successfully loaded ${Object.keys(benchmarkData).length} devices with ${availableHashModes.length} hash modes`;
        
        setTimeout(() => {
          loadingElement.classList.add('hidden');
          mainContent.classList.remove('hidden');
        }, 1000);
        
      } catch (error) {
        console.error('Error loading benchmark data:', error);
        loadingElement.innerHTML = '<div class="alert alert-error">Failed to load benchmark data. Please check the console for details.</div>';
      }
    }
    
    // Function to create or update chart
    function updateChart(selectedHashMode) {
      if (!selectedHashMode || !benchmarkData) return;
      
      const ctx = document.getElementById('performanceChart').getContext('2d');
      
      // Collect data for the selected hash mode
      const deviceData = [];
      const speeds = [];
      
      Object.entries(benchmarkData).forEach(([deviceName, hashModes]) => {
        if (hashModes[selectedHashMode]) {
          deviceData.push(deviceName);
          speeds.push(hashModes[selectedHashMode].speed);
        }
      });
      
      // Sort by speed (descending)
      const sortedData = deviceData
        .map((device, index) => ({ device, speed: speeds[index] }))
        .sort((a, b) => b.speed - a.speed);
      
      const sortedDevices = sortedData.map(item => item.device);
      const sortedSpeeds = sortedData.map(item => item.speed);
      
      // Calculate dynamic height based on number of devices
      const minHeight = 200; // Minimum height
      const heightPerDevice = 40; // Height per device (in pixels)
      const calculatedHeight = Math.max(minHeight, sortedDevices.length * heightPerDevice);
      
      // Set the chart container height
      const chartContainer = document.getElementById('chartContainer');
      chartContainer.style.height = `${calculatedHeight}px`;
      
      // Destroy existing chart
      if (chart) {
        chart.destroy();
      }
      
      // Create new chart (horizontal bar chart)
      chart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedDevices,
          datasets: [{
            label: 'Speed (H/s)',
            data: sortedSpeeds,
            backgroundColor: 'rgba(54, 162, 235, 0.6)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y', // This makes it horizontal
          responsive: true,
          maintainAspectRatio: false,
          aspectRatio: false, // Disable aspect ratio to use custom height
          scales: {
            x: {
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return formatSpeed(value);
                }
              }
            },
            y: {
              ticks: {
                font: {
                  size: 12
                }
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.dataset.label}: ${formatSpeed(context.parsed.x)}`;
                }
              }
            },
            legend: {
              display: false
            },
            // Add data labels plugin for speed labels
            datalabels: {
              display: true,
              color: '#333',
              font: {
                size: 11,
                weight: 'bold'
              },
              formatter: function(value, context) {
                return formatSpeed(value);
              },
              anchor: 'end',
              align: 'right',
              offset: 5
            }
          }
        }
      });
      
      // Update chart title
      const hashModeInfo = benchmarkData[sortedDevices[0]]?.[selectedHashMode];
      const modeName = hashModeInfo ? hashModeInfo.hashmode_name : 'Unknown';
      document.getElementById('chartTitle').textContent = 
        `GPU Performance Comparison - ${selectedHashMode} (${modeName})`;
    }
    
    // Function to initialize hash mode search functionality
    function initializeHashModeSearch() {
      const searchInput = document.getElementById('hashModeSearch');
      const dropdown = document.getElementById('hashModeDropdown');
      const clearButton = document.getElementById('clearSearch');
      
      // Initialize with all hash modes
      filteredHashModes = [...availableHashModes];
      renderDropdown();
      
      // Search functionality
      searchInput.addEventListener('input', function(e) {
        const query = e.target.value.toLowerCase().trim();
        
        if (query === '') {
          filteredHashModes = [...availableHashModes];
          clearButton.style.display = 'none';
        } else {
          filteredHashModes = availableHashModes.filter(mode => {
            const firstDeviceWithMode = Object.keys(benchmarkData).find(device => 
              benchmarkData[device][mode]
            );
            const modeName = firstDeviceWithMode ? 
              benchmarkData[firstDeviceWithMode][mode].hashmode_name : '';
            return mode.toLowerCase().includes(query) || 
                   modeName.toLowerCase().includes(query);
          });
          clearButton.style.display = 'block';
        }
        
        renderDropdown();
      });
      
      // Clear search
      clearButton.addEventListener('click', function() {
        searchInput.value = '';
        filteredHashModes = [...availableHashModes];
        clearButton.style.display = 'none';
        renderDropdown();
      });
      
      // Hide dropdown when clicking outside
      document.addEventListener('click', function(e) {
        if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
          dropdown.style.display = 'none';
        }
      });
      
      // Show dropdown when focusing on input
      searchInput.addEventListener('focus', function() {
        dropdown.style.display = 'block';
      });
    }
    
    // Function to render dropdown options
    function renderDropdown() {
      const dropdown = document.getElementById('hashModeDropdown');
      dropdown.innerHTML = '';
      
      if (filteredHashModes.length === 0) {
        const noResults = document.createElement('div');
        noResults.className = 'p-4 text-center text-gray-500';
        noResults.textContent = 'No hash modes found';
        dropdown.appendChild(noResults);
        return;
      }
      
      filteredHashModes.forEach(mode => {
        const option = document.createElement('div');
        option.className = 'p-3 hover:bg-base-200 cursor-pointer border-b border-base-200 last:border-b-0';
        
        // Get the hash mode name from the first device that has this mode
        const firstDeviceWithMode = Object.keys(benchmarkData).find(device => 
          benchmarkData[device][mode]
        );
        const modeName = firstDeviceWithMode ? 
          benchmarkData[firstDeviceWithMode][mode].hashmode_name : 'Unknown';
        
        option.innerHTML = `
          <div class="font-semibold">${mode}</div>
          <div class="text-sm text-gray-600">${modeName}</div>
        `;
        
        option.addEventListener('click', function() {
          selectHashMode(mode, modeName);
        });
        
        dropdown.appendChild(option);
      });
    }
    
    // Function to select a hash mode
    function selectHashMode(mode, modeName) {
      selectedHashMode = mode;
      const searchInput = document.getElementById('hashModeSearch');
      const dropdown = document.getElementById('hashModeDropdown');
      const clearButton = document.getElementById('clearSearch');
      
      searchInput.value = `${mode} (${modeName})`;
      dropdown.style.display = 'none';
      clearButton.style.display = 'block';
      
      updateChart(mode);
    }
    
    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      loadAllBenchmarkData();
    });
  </script>
</body>
</html>
